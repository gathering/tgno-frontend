---
interface Props {
  targetDate: string; // ISO 8601
  confetti?: boolean;
  endMessage?: string;
}

const {
  targetDate,
  confetti = false,
  endMessage = "Countdown complete",
} = Astro.props;
---

<div
  class="countdown flex flex-wrap items-center justify-center gap-x-3 gap-y-1 sm:gap-x-4 rounded-xl text-white whitespace-nowrap leading-none"
  data-target={targetDate}
  data-confetti={confetti ? "true" : "false"}
  data-end-message={endMessage}
>
  <div class="text-center">
    <div
      class="text-lg sm:text-2xl md:text-3xl font-bold tabular-nums"
      data-days
    >
      0
    </div>
    <div class="text-xs uppercase tracking-wide text-neutral-400">Days</div>
  </div>

  <div class="text-center">
    <div
      class="text-lg sm:text-2xl md:text-3xl font-bold tabular-nums"
      data-hours
    >
      0
    </div>
    <div class="text-xs uppercase tracking-wide text-neutral-400">Hours</div>
  </div>

  <div class="text-center">
    <div
      class="text-lg sm:text-2xl md:text-3xl font-bold tabular-nums"
      data-minutes
    >
      0
    </div>
    <div class="text-xs uppercase tracking-wide text-neutral-400">Minutes</div>
  </div>

  <div class="text-center">
    <div
      class="text-lg sm:text-2xl md:text-3xl font-bold tabular-nums"
      data-seconds
    >
      0
    </div>
    <div class="text-xs uppercase tracking-wide text-neutral-400">Seconds</div>
  </div>
</div>

<script>
  type Parts = {
    days: HTMLElement;
    hours: HTMLElement;
    minutes: HTMLElement;
    seconds: HTMLElement;
  };

  function getParts(container: Element): Parts {
    const days = container.querySelector("[data-days]");
    const hours = container.querySelector("[data-hours]");
    const minutes = container.querySelector("[data-minutes]");
    const seconds = container.querySelector("[data-seconds]");

    if (!(days && hours && minutes && seconds)) {
      throw new Error("Countdown parts not found");
    }

    return {
      days: days as HTMLElement,
      hours: hours as HTMLElement,
      minutes: minutes as HTMLElement,
      seconds: seconds as HTMLElement,
    };
  }

  function pad2(n: number) {
    return String(n).padStart(2, "0");
  }

  function render(parts: Parts, diffMs: number) {
    const days = Math.floor(diffMs / 86_400_000);
    const hours = Math.floor((diffMs / 3_600_000) % 24);
    const minutes = Math.floor((diffMs / 60_000) % 60);
    const seconds = Math.floor((diffMs / 1_000) % 60);

    parts.days.textContent = String(days);
    parts.hours.textContent = pad2(hours);
    parts.minutes.textContent = pad2(minutes);
    parts.seconds.textContent = pad2(seconds);
  }

  async function fireConfetti() {
    const mod = await import("canvas-confetti");
    const confetti = mod.default;

    confetti({
      particleCount: 80,
      angle: 60,
      spread: 70,
      origin: { x: 0, y: 0.7 },
    });
    confetti({
      particleCount: 80,
      angle: 120,
      spread: 70,
      origin: { x: 1, y: 0.7 },
    });
  }

  function initCountdown(container: HTMLElement) {
    const targetAttr = container.dataset.target;
    if (!targetAttr) throw new Error("Missing target date");

    const targetTime = new Date(targetAttr).getTime();
    if (Number.isNaN(targetTime)) throw new Error("Invalid target date");

    const confettiEnabled = container.dataset.confetti === "true";
    const endMessage = container.dataset.endMessage || "Countdown complete";
    const parts = getParts(container);

    let timer: number | undefined;
    let launched = false;

    async function launch() {
      if (launched) return;
      launched = true;

      if (timer) window.clearInterval(timer);

      // Replace countdown with end message (safe textContent)
      container.innerHTML = "";
      const span = document.createElement("span");
      span.className =
        "text-2xl font-semibold bg-gradient-to-r from-[#12abcf] to-[#e6693b] bg-clip-text text-transparent";
      span.textContent = endMessage;
      container.appendChild(span);

      if (confettiEnabled) {
        try {
          await fireConfetti();
        } catch {
          // If the library isn't installed or fails to load, just skip silently.
        }
      }
    }

    function update() {
      const diff = targetTime - Date.now();
      if (diff <= 0) void launch();
      else render(parts, diff);
    }

    update();
    timer = window.setInterval(update, 1000);
  }

  // Support multiple countdowns on a page
  document.querySelectorAll<HTMLElement>(".countdown").forEach((el) => {
    try {
      initCountdown(el);
    } catch (err) {
      console.error(err);
    }
  });
</script>
