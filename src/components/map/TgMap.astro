---
import "leaflet/dist/leaflet.css";
import type { MapItem } from "../../types";
import FloatingNav from "../floating-nav/FloatingNav.astro";

export type Props = {
  locations: MapItem[];
};

const { locations: ssrLocations } = Astro.props;
---

<script>
  import L, { type LatLngBoundsExpression } from "leaflet";
  import {
    pad,
    isMapItem,
    toLatLngTuple,
    slugifyMapItemName,
  } from "../../utils/map";
  import type { MapItem } from "../../types";
  interface Target extends MapItem {
    slug: string;
    element: L.Rectangle | L.Polygon;
    calendarQuery?: string[];
  }

  class TGMap extends HTMLElement {
    currentTarget: string = "";
    map?: L.Map = undefined;
    mapBounds?: LatLngBoundsExpression = undefined;
    targets: Record<string, Target> = {};
    popup?: L.Popup = undefined;

    setTarget(slug: string) {
      let target = slug;

      if (this.currentTarget === target || !this.targets[target]) {
        target = "";
      }

      this.goToTarget(this.targets[target]);
      this.currentTarget = target;
    }

    goToTarget(target?: Target) {
      this.showPopup(target);

      if (!target) {
        if (this.map && this.mapBounds) {
          this.map.fitBounds(this.mapBounds);
        }
        return;
      }

      this.map?.fitBounds(target.element.getBounds(), {
        duration: 0.3,
        padding: [75, 75],
        animate: true,
      });
    }

    showPopup(target?: Target) {
      if (this.popup) {
        this.popup.remove();
      }
      if (!target || !this.map) {
        return;
      }

      const { slug, name, presentation } = target;
      const { type, calendarQuery } = presentation || {};

      this.popup = new L.Popup({
        className: type,
        closeButton: false,
      })
        .setLatLng(target.element.getBounds().getCenter())
        .setContent((_layer) => {
          const contents = document.createElement("div");

          const heading = document.createElement("h3");
          heading.textContent = name;
          heading.onclick = () => this.onTargetClick(slug);
          contents.append(heading);

          if (calendarQuery) {
            const calendarLink = document.createElement("a");
            calendarLink.classList.add("calendar-link");
            calendarLink.target = "_blank";
            calendarLink.href = `/schedule?tags=${calendarQuery.join(",")}`;
            calendarLink.textContent = "Se programmet";
            contents.append(calendarLink);
          }

          return contents;
        })
        .openOn(this.map);
    }

    onNavigate(slug: string) {
      this.setTarget(slug);
    }

    onTargetClick(slug: string) {
      this.setTarget(slug);
    }

    onResetClick() {
      this.setTarget("");
    }

    connectedCallback() {
      let locations: MapItem[] = [];
      try {
        locations = JSON.parse(this.dataset.locations || "").filter(isMapItem);
      } catch (e) {
        console.log(
          `Unable to import map locations`,
          this.dataset.locations,
          e,
        );
      }

      // Initialize the map (local reference so that TS doesn't complain)
      const map = L.map("map", {
        crs: L.CRS.Simple,
        minZoom: -2,
        // TODO: Activate on mobile, or where we need to avoid the "pop in" effect
        // renderer: L.canvas({ padding: 3 }),
        attributionControl: false,
      });
      this.map = map;
      this.mapBounds = [
        { x: 0, y: 0 },
        { x: 3308, y: 2339 },
      ].map(toLatLngTuple);

      // TODO: Replace with proper map (tiled if better for performance)
      L.imageOverlay(
        "/TG25_sitemap_low_res_placeholder.jpg",
        this.mapBounds,
      ).addTo(map);

      map.fitBounds(this.mapBounds);
      map.setMaxBounds(this.mapBounds);

      locations.forEach((location, index) => {
        const {
          name,
          width,
          height,
          pos,
          polygon: rawPolygon,
          icon,
          presentation,
        } = location;
        const slug = `${slugifyMapItemName(name)}-${index}`;
        const bounds = rawPolygon
          ? rawPolygon.map((cords) => ({
              x: cords.x + pos.x,
              y: cords.y + pos.y,
            }))
          : [
              pos,
              {
                x: pos.x + width,
                y: pos.y + height,
              },
            ];

        // TODO: Dealing with polygon shapes?
        if (icon && !rawPolygon && bounds.length === 2) {
          L.imageOverlay(
            icon,
            // @ts-ignore-next-line
            pad(presentation.padding ?? width / 10, bounds).map(toLatLngTuple),
            {
              zIndex: 201, // Polygons are 200?
              interactive: false,
            },
          ).addTo(map);
        }

        const targetConfig = {
          noClip: true,
          className: presentation?.type || "unknown",
        };
        const target = rawPolygon
          ? new L.Polygon(bounds.map(toLatLngTuple), targetConfig)
          : new L.Rectangle(bounds.map(toLatLngTuple), targetConfig);
        target.addTo(map);

        this.targets[slug] = {
          slug,
          ...location,
          element: target,
        };

        if (presentation?.interactive === false) {
          return;
        }

        target.on("click", () => this.onTargetClick(slug));
      });

      // TODO: Only run on mobile (usage on desktop sizes tend to cause a lot of performance issues)
      Object.values(this.targets).some((target) => {
        map.getRenderer(target.element).options.padding = 2;
        return true;
      });

      this.querySelectorAll("[data-part=nav-item]").forEach((el) => {
        el.addEventListener("click", () => {
          const target = el.getAttribute("data-target");
          if (target) {
            this.onNavigate(target);
          }
        });
      });

      this.querySelectorAll("button[data-action=reset]").forEach((button) => {
        button.addEventListener("click", this.onResetClick);
      });

      map.on("click", (event) => {
        // @ts-ignore-next-line
        if (!window.debug) {
          return;
        }
        console.log({
          x: event.latlng.lng,
          y: event.latlng.lat,
        });
      });
    }
  }

  customElements.define("tg-map", TGMap);
</script>

<style>
  tg-map {
    .leaflet-container {
      background-color: theme("colors.white");
    }
    .leaflet-interactive {
      &.stage {
        fill-opacity: 1;
        fill: theme("colors.backgroundSecondary");
        stroke: blue;
      }
      &.stand {
        fill-opacity: 1;
        fill: theme("colors.backgroundSecondary");
        stroke: red;
      }
      &.food {
        fill-opacity: 1;
        fill: theme("colors.backgroundSecondary");
        stroke: green;
      }
      &.placeholder,
      &.unknown {
        fill-opacity: 1;
        fill: hotpink;
        stroke: black;
      }
    }
    .leaflet-popup {
      color: theme("colors.white");
      .leaflet-container {
        padding: theme("padding.4");
      }
      h3 {
        font-size: theme("fontSize.2xl");
        font-weight: theme("fontWeight.bold");
        margin-bottom: theme("margin.2");
      }
      .calendar-link {
        display: block;
        padding: theme("padding.2") theme("padding.4");
        margin: theme("margin.4") 0 theme("margin.6");
        text-align: center;
        font-size: theme("fontSize.base");
        font-weight: theme("fontWeight.bold");
        background-color: theme("colors.yellow.500");
        color: theme("colors.black");
        border-radius: theme("borderRadius.lg");
      }
      p {
        font-size: theme("fontSize.base");
        margin: theme("margin.2") 0;
      }
      &.stand {
        .leaflet-popup-content-wrapper,
        .leaflet-popup-tip {
          color: theme("colors.black");
          background-color: theme("colors.yellow.400");
        }
      }
      &.stage {
        .leaflet-popup-content-wrapper,
        .leaflet-popup-tip {
          color: theme("colors.white");
          background-color: theme("colors.backgroundSecondary");
        }
      }
    }
  }
</style>

<tg-map data-locations={JSON.stringify(ssrLocations)}>
  <div class="relative z-[999]">
    <FloatingNav closeOnNavigate>
      <span slot="content">
        <slot name="nav" />
      </span>
    </FloatingNav>
  </div>
  <div id="map" class="fixed bg-black top-32 right-0 bottom-0 left-0 z-[10]">
  </div>
</tg-map>
